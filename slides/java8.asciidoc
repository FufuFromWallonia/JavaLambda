:source-highlighter: coderay
:revealjs_transition: fade
:revealjs_theme: solarized
:revealjs_history: true
:revealjs_center: false

= Java 8, la version avant Java 9 ;)
Partiellement inspiré par NinjaSquad :)

== !

Qui utilise *Java5* ?

== !

Qui utilise *Java6* ?

== !

Qui utilise *Java7* ?

== !

[quote, No one - ever]
____
Java7 a changé ma façon de développer!
____

[NOTE.speaker]
--
Qu'y a-t-il eu de nouveau dans Java 7?
Quelques APIs: nio2, quelques ajouts dans concurrency, JDBC 4.1...
Mais au quotidien, qu'est-ce qui a changé?
--

== LA METHODE FOREACH

== foreach() 1/2

.Traversal avec un Iterator
[source,java,indent=0]
----
include::../code/src/main/java/java8/foreach/TraversalExample.java[tag=traversalIterator]
----

== foreach() 2/2

.Traversal avec la méthode foreach()
[source,java,indent=0]
----
include::../code/src/main/java/java8/foreach/TraversalExample.java[tag=traversalForeach]
----

== LES DEFAULT METHODS

== Augmenter une interface

.Comportements par défaut
[source,java,indent=0]
----
include::../code/src/main/java/java8/defmethod/DefaultMethodExample.java[tag=orderableDefaultMethods]
----

== Implémenter l'interface

.Bénéficier des comportements par défaut
[source,java,indent=0]
----
include::../code/src/main/java/java8/defmethod/DefaultMethodExample.java[tag=orderableImplemented]
----

== Vérifier le comportement

.Orderable in action
[source,java,indent=0]
----
include::../code/src/main/java/java8/defmethod/DefaultMethodExample.java[tag=orderableInAction]
----

== LES (EXPRESSIONS) LAMBDAS

== Comparator 1/2

.Comparator avec une classe anonyme
[source,java,indent=0]
----
include::../code/src/main/java/java8/lambda/ComparatorExample.java[tag=comparatorAnonymous]
----

== Comparator 2/2

.Comparator avec une expression lambda
[source,java,indent=0]
----
include::../code/src/main/java/java8/lambda/ComparatorExample.java[tag=comparatorLambda]
----

== Runnable 1/2

.Runnable avec une classe anonyme
[source,java,indent=0]
----
include::../code/src/main/java/java8/lambda/RunnableExample.java[tag=runnableAnonymous]
----

== Runnable 2/2

.Runnable avec une expression lambda
[source,java,indent=0]
----
include::../code/src/main/java/java8/lambda/RunnableExample.java[tag=runnableLambda]
----

== Magie

Toute *interface* avec *une seule méthode* peut être utilisée comme expression lambda.

== Souvenez-vous: foreach() 2/2

.Traversal avec la méthode foreach()
[source,java,indent=0]
----
include::../code/src/main/java/java8/foreach/TraversalExample.java[tag=traversalForeach]
----

== Souvenez-vous: foreach() 2/2

.Traversal avec la méthode foreach()
[source,java,indent=0]
----
include::../code/src/main/java/java8/foreach/TraversalExample.java[tag=traversalForeach]
----
Consumer est une *interface* avec *une seule méthode*, une @FunctionalInterface.

== foreach() + Lambda

.Traversal avec la méthode foreach() et une expression Lambda
[source,java,indent=0]
----
include::../code/src/main/java/java8/foreach/TraversalExample.java[tag=traversalForeachLambda]
----

== Exemples d'expressions Lambda 1/2

[source,java,indent=0]
----
(int x) -> { return x+1; }
(int x) -> x+1
(x) -> x+1
x -> x+1
(int x, int y) -> x+y
(x,y) -> x+y
(x, int y) -> x+y #FAIL
----

[NOTE.speaker]
--
(int x) -> { return x+1; }   // un seul argument avec déclaration de type

(int x) -> x+1               // même chose mais avec retour implicite

(x) -> x+1                   // même chose avec inférence du type

x -> x+1                     // Parenthèses optionnelles pour un argument unique avec inférence de type

(int x, int y) -> x+y      // Plusieurs arguments avec déclaration de type

(x,y) -> x+y               // Plusieurs arguments avec inférence de type pour tous

(x, int y) -> x+y          // Illégal: impossible de mélanger déclaration et inférence de type
--

== Exemples d'expressions Lambda 1/2

[source,java,indent=0]
----
() -> {}
() -> { return 42; }
() -> { System.gc(); }
() -> 42
() -> null
----

[NOTE.speaker]
--
() -> {}		     // Pas de paramètres; sans retour (void)

() -> { return 42; }         // Pas de paramètres, le corps est un bloc avec un retour

() -> { System.gc(); }       // Pas de paramètres, le corps est un bloc, sans retour (void)

() -> 42		     // Pas de paramètres, le corps est une expression avec retour implicite

() -> null                   // Pas de paramètres, le corps est une expression avec retour implicite nul
--

== Toujours trop verbeux?

== Référence de Méthode/Constructeur 1/2

.Comparator avec des expressions lambda "classiques"
[source,java,indent=0]
----
include::../code/src/main/java/java8/methodref/MethodReferenceExample.java[tag=comparatorLambda]
----

== Référence de Méthode/Constructeur 2/2

.Comparator avec des références de méthodes
[source,java,indent=0]
----
include::../code/src/main/java/java8/methodref/MethodReferenceExample.java[tag=comparatorLambdaMethodReference]
----

== Exemples de références de méthodes / constructeurs

[source,java,indent=0]
----
System::getProperty
System.out::println
"abc"::length
ArrayList::new
int[]::new
----

[NOTE.speaker]
--
System::getProperty          // Réference de méthode statique

System.out::println          // Référence de méthode d'instance

"abc"::length                // Référence de méthode sur une expression

ArrayList::new               // Référence de constructeur sur une classe

int[]::new                   // Référence de constructeur sur un tableau
--

== C'EST CONCIS, MAIS POURQUOI?

== POUR LES STREAMS!!!!!

== java.util.stream 1/2

.Filtrage et somme à l'ancienne avec une boucle
[source,java,indent=0]
----
include::../code/src/main/java/java8/streams/FilterExample.java[tag=filterLoop]
----
On filtre les éléments supérieurs à 10 et on les additionne.

== java.util.stream 2/2

.Filtrage et somme à la sauce stream avec stream() filter() et mapTo..()
[source,java,indent=0]
----
include::../code/src/main/java/java8/streams/FilterExample.java[tag=filterStream]
----
On filtre les éléments supérieurs à 10 et on les additionne.

== java.util.stream 2/2

.Filtrage et somme à la sauce stream avec stream() filter() et mapTo..()
[source,java,indent=0]
----
include::../code/src/main/java/java8/streams/FilterExample.java[tag=filterStream]
----
On filtre les éléments supérieurs à 10 et on les additionne.
Le paramètre filter() est de type Predicate, et celui de mapTo...() est de type Function.
Ce sont tous deux des opérations intermédiaires (qui renvoient un stream),
quand sum() est une opération terminale, (qui ne renvoie pas de stream)
[NOTE.speaker]
--
sum() est une méthode terminale d'IntStream, pas de Stream<Integer> d'où le besoin de mapToInt().
--
